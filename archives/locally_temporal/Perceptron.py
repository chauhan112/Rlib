class Perceptron:    def _perceptron(X, w):        return np.sign(np.dot(X, w))    def _pla(X, y, w_t):        for i in range(len(X)):            x_t = np.hstack((np.array([1]), X[i]))            y_t = y[i]            if y_t != Perceptron._perceptron(x_t, w_t):                return Perceptron._pla(X, y, w_t + y_t*x_t)        return w_t    def fit(X, y):        d = len(X[0])        Perceptron.w = np.ones((d+1,1)).flatten()        Perceptron.w = Perceptron._pla(X,y, w)        return Perceptron.w        def predict(X):        x_t = np.hstack((np.ones((len(X),1)), X))        return np.array([Perceptron._perceptron(x1, Perceptron.w) for x1 in x_t])        def error(X, y):        out = Perceptron.predict(X)        n = 0        for i, val in enumerate(y):            if(val != out[i]):                n += 1        return n/len(out)